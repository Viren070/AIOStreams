import { Cache } from '../utils/cache.js';
import { makeRequest } from '../utils/http.js';
import { Env } from '../utils/env.js';
import { IdParser } from '../utils/id-parser.js';
import { AnimeDatabase } from '../utils/anime-database.js';

export type ParsedPosterId = {
  idType: 'tmdb' | 'imdb' | 'tvdb';
  idValue: string;
};

export abstract class BasePosterService {
  protected readonly apiKey: string;
  protected readonly apiKeyValidationCache: Cache<string, boolean>;
  protected readonly posterCheckCache: Cache<string, string>;

  /** Human-readable service name, used in error messages. */
  abstract readonly serviceName: string;

  /** URL domains that identify posters already generated by this service. */
  abstract readonly ownDomains: string[];

  /** The redirect path segment used in the poster redirect API, e.g. 'rpdb'. */
  abstract readonly redirectPathSegment: string;

  constructor(apiKey: string, cacheNamespace: string) {
    this.apiKey = apiKey.trim();
    if (!this.apiKey) {
      throw new Error(`${this.constructor.name} API key is not set`);
    }
    this.apiKeyValidationCache = Cache.getInstance<string, boolean>(
      `${cacheNamespace}ApiKey`
    );
    this.posterCheckCache = Cache.getInstance<string, string>(
      `${cacheNamespace}Check`
    );
  }

  /** Validate the API key against the upstream service. */
  abstract validateApiKey(): Promise<boolean>;

  /**
   * Build the poster URL for a given parsed ID.
   * Does NOT include existence checking â€” that's handled by the base class.
   */
  protected abstract buildPosterUrl(idType: string, idValue: string): string;

  /**
   * ID types supported by this service. Override to customise which types
   * are supported and in what priority for fallback from AnimeDatabase.
   * Defaults to tmdb, imdb, tvdb.
   */
  protected get supportedIdTypes(): ('tmdb' | 'imdb' | 'tvdb')[] {
    return ['tmdb', 'imdb', 'tvdb'];
  }

  /**
   * Parse a Stremio-style `id` + `type` into an ID type and value
   * that this poster service understands.
   */
  protected parseId(type: string, id: string): ParsedPosterId | null {
    const parsedId = IdParser.parse(id, type);
    if (!parsedId) return null;

    const supported = this.supportedIdTypes;

    switch (parsedId.type) {
      case 'themoviedbId':
        if (!supported.includes('tmdb')) break;
        return { idType: 'tmdb', idValue: `${type}-${parsedId.value}` };
      case 'imdbId':
        if (!supported.includes('imdb')) break;
        return { idType: 'imdb', idValue: parsedId.value.toString() };
      case 'thetvdbId': {
        if (!supported.includes('tvdb')) break;
        if (type === 'movie') break; // tvdb not supported for movies
        return { idType: 'tvdb', idValue: parsedId.value.toString() };
      }
    }

    // Fallback: try AnimeDatabase mapping
    const entry = AnimeDatabase.getInstance().getEntryById(
      parsedId.type,
      parsedId.value
    );
    if (!entry) return null;

    // Try supported types in priority order
    for (const st of supported) {
      switch (st) {
        case 'tvdb':
          if (entry.mappings?.thetvdbId && type === 'series') {
            return {
              idType: 'tvdb',
              idValue: `${entry.mappings.thetvdbId}`,
            };
          }
          break;
        case 'tmdb':
          if (entry.mappings?.themoviedbId) {
            return {
              idType: 'tmdb',
              idValue: `${type}-${entry.mappings.themoviedbId}`,
            };
          }
          break;
        case 'imdb':
          if (entry.mappings?.imdbId) {
            return {
              idType: 'imdb',
              idValue: entry.mappings.imdbId.toString(),
            };
          }
          break;
      }
    }

    return null;
  }

  /**
   * Get the poster URL for a given Stremio item.
   * @param checkExists If true, HEAD-checks the URL exists before returning.
   */
  public async getPosterUrl(
    type: string,
    id: string,
    checkExists: boolean = true
  ): Promise<string | null> {
    const parsed = this.parseId(type, id);
    if (!parsed) return null;
    const { idType, idValue } = parsed;

    const cacheKey = this.getCacheKey(type, id);
    const cached = await this.posterCheckCache.get(cacheKey);
    if (cached !== undefined) {
      return cached;
    }

    const posterUrl = this.buildPosterUrl(idType, idValue);
    if (!checkExists) {
      return posterUrl;
    }

    try {
      const response = await makeRequest(posterUrl, {
        method: 'HEAD',
        timeout: 3000,
        ignoreRecursion: true,
      });
      if (!response.ok) {
        return null;
      }
    } catch {
      return null;
    }

    this.posterCheckCache.set(cacheKey, posterUrl, 24 * 60 * 60);
    return posterUrl;
  }

  /** Build the cache key. Override for services that need extra params. */
  protected getCacheKey(type: string, id: string): string {
    return `${type}-${id}-${this.apiKey}`;
  }

  /** Check whether a poster URL is already from this service. */
  public isPosterFromThisService(posterUrl: string): boolean {
    return this.ownDomains.some((d) => posterUrl.includes(d));
  }

  /**
   * Build a redirect URL that goes through the AIOStreams poster redirect API.
   */
  public buildRedirectUrl(
    itemId: string,
    type: string,
    fallbackPoster: string
  ): string {
    const url = new URL(Env.BASE_URL);
    url.pathname = `/api/v1/posters/${this.redirectPathSegment}`;
    url.searchParams.set('id', itemId);
    url.searchParams.set('type', type);
    url.searchParams.set('fallback', fallbackPoster);
    url.searchParams.set('apiKey', this.apiKey);
    this.appendRedirectParams(url);
    return url.toString();
  }

  /** Override to append extra query params to the redirect URL. */
  protected appendRedirectParams(_url: URL): void {}

  /**
   * Build additional search params from query for the poster route handler.
   * Override in subclasses that need extra params (e.g. profileId).
   */
  public static fromQueryParams(
    _query: Record<string, string>
  ): Record<string, string> {
    return {};
  }
}
